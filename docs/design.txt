Backend:
    Database curDbase;
    List<Database> databases;
    Answer { NONE, YES, YESALL, NO, NOALL } answer = NONE;
    Operation { NONE, ENTRY_ADD, ENTRY_DEL, ENTRY_COPY, ENTRY_MOVE, ENTRY_EDIT, ENTRY_FIND } curOp = NONE;
    String entryItem, entryDesc, itemName, text;
    List<Index> dbSelection;

ui:
    Dialog dbaseDialog;

// [WYNN_5]
ui::slot_database_addClicked():
    backend.dbaseEntryAdd();

backend::dbaseEntryAdd():
    !dbase:
        signal_warning("Invalid dbase"); 
        return;
    cleanupOperation();
    curOp = ENTRY_ADD;
    signal_dbaseEntry("", "");

signal_warning(msg) -> ui::slot_backend_warning():
    MsgBox::warning(msg);

signal_dbaseEntry(item, desc) -> ui::slot_backend_dbaseEntry():
    dbaseDialog.open(item, desc);

ui::slot_entryDialog_accepted():
    item.empty || desc.empty:
        MsgBox(); 
        return;
    backend.entry(item, desc);

ui::slot_entryDialog_rejected():
    backend.answer(CANCEL);

backend::entry(item, desc):
    entryItem = item;
    entryDesc = desc;
    continueOperation();

// TODO: do actual work on a worker thread?
backend::continueOperation():
    curOp == ENTRY_ADD:
        answer == CANCEL: 
            cleanupOperation();Â 
            return;
        answer == YES || YESALL: dupIgnore = true;
        error = curDbase.add(entryItem, entryDesc, dupIgnore);
        error == DUPLICATE: 
            signal_question("Accept duplicate?", "blahblah", YES | NO | CANCEL); 
            return;
        signal_dbaseUpdated(idx);
        return;
    curOp == ENTRY_DEL:
        answer == YES: 
            curDbase->remove(idxs);
        else: 
            error();

        signal_dbaseUpdated(idx);
    curOp == ENTRY_COPY || ENTRY_MOVE || ENTRY_EDIT:
        target = databases(itemName);
        idx <- dbSelection:
            answer == CANCEL: break;
            answer != NO:
                answer == YES || YESALL: dupIgnore = true;
                curOp == ENTRY_EDIT:
                    error = target->alter(index, entryItem, entryDesc, dupIgnore);
                else:
                    entry = curDbase->entry(idx);
                    error = target->add(entry, dupIgnore);

                error == DUPLICATE && answer != NO || NOALL: // ask about duplicate unless already answered no
                    signal_question("Accept duplicate?", "blabla", YES | NO | YESALL | NOALL | CANCEL); 
                    return; // will retry same entry next time around

                curOp == ENTRY_MOVE && error == OK: 
                    curDbase->remove(idx);
            
            answer == YES || NO: 
                answer = NONE; // yes/no answer good only for one iteration

            dbSelection->remove(idx);
            curOp == ENTRY_EDIT:
                signal_dbaseEntry(dbSelection.front()); // pop next dialog for editing
                return; 
    curOp == ENTRY_FIND:
        idx = dbSelection.front();
        found = curDbase->findEntry(text, idx);
        fond < 0:
            found = curDbase->findEntry(text, 0);
        found < 0:
            signal_warning("Nothing found");
        signal_dbaseFound(found);
    else: 
        error(); // no operation to continue

backend::cleanupOperation():
    curOp = NONE;
    answer = NONE;
    entryItem = entryDesc = itemName = "";
    dbSelection.clear();

signal_question(title, msg, buttons) -> ui::slot_backend_question():
    ans = MsgBox(title, msg, buttons);
    backend.answer(ans);

backend::answer(ans):
    curOp == NONE || answer != NONE:
        error(); // answer to unasked question or old answer not cleaned
    answer = ans;
    continueOperation();

signal_dbaseUpdated(focus) -> ui::slot_backend_dbaseUpdated():
    table.setFocus(),setSelection(focus);

// [WYNN_6]
ui::slot_database_removeClicked():
    backend.dbaseEntryRemove(selection);

backend::dbaseEntryRemove(selection):
    !dbase || selection.empty():
        signal_warning();
        return;
    cleanupOperation();
    curOp = ENTRY_DEL;
    dbSelection = selection;
    signal_question("Delete 123 item(s)?", "blabla", YES | NO);

// [WYNN_7]
ui::slot_database_copyClicked():
    backend.dbaseEntryCopy(selection, false);

// [WYNN_8]
ui::slot_database_moveClicked():
    backend.dbaseEntryCopy(selection, true);

backend::dbaseEntryCopy(selection, move):
    !dbase || selection.empty():
        signal_warning();
        return;
    cleanupOperation();
    move: 
        curOp = ENTRY_MOVE 
    else: 
        curOp = ENTRY_COPY;
    dbSelection = selection;
    signal_selection("Select target", "blabla", dbNames)

 signal_selection -> ui::slot_backend_selection(title, msg, items):
    ans = InputDialog::select(title, msg, items);
    backend.item(ans);

backend::item(name):
    itemName = name;
    continueOperation();

// [WYNN_9]
ui::slot_database_editClicked():
    backend.dbaseEntryEdit(selection);

backend::dbaseEntryEdit(selection):
    !dbase || selection.empty():
        signal_warning();
        return;
    cleanupOperation();
    dbSelection = selection;
    curOp = ENTRY_EDIT;
    signal_dbaseEntry(dbSelection.front());

// [WYNN_10]
ui::slot_database_findClicked():
    backend.dbaseEntryFind(selection, expr);

backend::dbaseEntryFind(selection, expr):
    !dbase || selection.empty() || expr.empty():
        signal_warning();
        return;
    cleanupOperation();
    dbSelection = selection;
    curOp = ENTRY_FIND;
    signal_text("Input string");

signal_text(title, msg) -> ui::slot_backend_text():
    expr = DialogBox();
    backend.text(expr);

backend::text(str):
    text = str;
    continueOperation();

signal_dbaseFound(found) -> ui::slot_backend_dbaseEntryFound(found):
    table.select(found);